## Hadoop2 - 네임노드 HA

#### 네임노드가 중요한 이유

- **네임노드가 정상적으로 동작하지 않을 경우 모든 클라이언트가 HDFS에 접근할 수 없다.**
- **네임노드의 파일 시스템 이미지에 문제가 생길 경우에도 HDFS에 저장된 데이터를 조회할 수 없음.** **<u>파일 시스템 이미지에 HDFS의 디렉터리 구조와 파일 위치가 모두 보관되어 있기 때문에</u>**, 이 정보가 유실될 경우 블록에 접근하기 위한 통로가 없어진다.
- **네임노드의 에디트로그에 문제가 생길 경우에도 데이터가 유실될 확률이 높다.** **네임노드는 데이터 갱신 내역을 에디터로그에 저장**하고, 파일 시스템 이미지는 메모리에서 관리한다. **보조네임노드는 체크포인팅 작업을 통해 에디트 로그를 파일 시스템 이미지에 갱신**하는데, **만약 체크포인트가 만들어지기 전에 에디트로그가 손상되고, 네임노드가 재시작된다면 손상된 에디트로그는 파일 시스템 이미지에 반영되지 않은 채 네임노드가 구동된다.**

<br>

#### 기존 하둡의 해결방안

> 하둡을 도입하는 회사는 **항상 네임노드 이중화에 대해 고민하며 다양한 시도를 함**

- 아바타노드 of facebook
- 체크포인팅 주기 조절
- 에디트로그 수시 백업
- 리눅스 운영체제 관점에서 이중화

<br>

**다양한 시도 끝에 2012년 후반 쯤 하둡2에 네임노드HA 기능 추가**

---

#### 네임노드 HA 아키텍처

<img src="https://user-images.githubusercontent.com/71415474/114975235-d89bdc00-9ebe-11eb-8bd5-0a616c1b6389.PNG" alt="hadoop_24" style="zoom:67%;" />

- **저널노드 (JournalNode)**

  > **HDFS에 저장된 파일을 수정할 경우 에디트로그가 발생. 기존 하둡1은 에디트로그를 네임노드에만 저장**했었음.  
  > **하둡2에서는 에디트로그를 여러 서버에 복제해서 저장**하는데, **이를 위해 저널노드라는 컴포넌트를 제공**하고 별도의 데몬으로 실행한다.

  - **에디트로그를 저널노드가 실행되는 서버의 로컬디스크에 저장**한다.
  - **네임노드는 저널노드에 접근하기 위한 클라이언트**가 된다.
    - **액티브 네임노드: 에디트로그 저장 권한**
    - **스탠바이 네임노드: 에디트로그 조회만 요청**
  - 저널노드는 **반드시 3개 이상 실행**되어야 하며, **홀수 단위**로만 실행 가능하다.
  - **한 대의 서버에서 저널노드 3개를 실행하는게 아니라, 별도의 3대의 서버에 각각 저널노드 실행**
  - **N개의 저널노드는 동일한 에디트로그를 유지**하고 있음. 따라서 **한 대에 문제가 생겨도 네임노드 입장에서는 문제 없음**
  - 네임노드가 저널노드로부터 영향을 받지 않으려면 저널노드는 **`(전체 저널노드 개수/2) + 1` 개 만큼 실행**되어야 한다.
  - **저널노드는 시스템 리소스를 적게 사용하는 데몬**이다. 따라서 네임노드, 잡트래커, 리소스매니저 같은 데몬과 같은 서버에 있어도 문제가 되지 않는다.

  

- **주키퍼**

  > 네임노드 HA를 구성할 경우, **어떠한 네임노드가 액티브 네임노드이고 스탠바이 네임노드인지 저장할 곳이 필요**하다.

  - 주키퍼는 **네임노드 HA 상태 정보를 저장하기 위한 저장소**이다.
  - 하둡 대표 에코시스템 중 하나로 **애플리케이션들이 잘 동작하도록 중재**한다.  -> **분산 시스템의 코디네이터**
    - 네이밍, 분산 동기화, 메시지 큐, 알림 시스템과 같은 기능 제공
  - 주키퍼는 **중복 서비스를 이용한 고가용성**을 제공
    - **주키퍼 마스터를 홀수 단위**로 실행
    - 주키퍼 클라이언트는 **주키퍼 마스터가 응답하지 않을 경우 다른 주키퍼 마스터에게 요청**함
    - **주키퍼 마스터가 여러대일 경우 한 대가 리더, 나머지는 리더를 따르는 팔로워로 설정**된다.
    - 각 주키퍼 마스터는 동일한 주키퍼 데이터를 복제하고 있기 때문에, 클라이언트로부터 데이터조회 요청이 오면 자신이 보관하고 있는 데이터를 이용하여 응답한다.
    - **모든 쓰기 요청은 리더 주키퍼 마스터에게  보내진다.** 리더는 **이를 팔로워들에게 반영**하며, **과반수 이상의 주키퍼 마스터에 적용이 완료되면 쓰기 요청을 한 클라이언트에게 쓰기가 정상적으로 완료되었다는 신호를 보낸다.**

- **ZKFC** (ZooKeeperFailoverController)

  > 주키퍼에 **네임노드 HA의 상태를 저장하려면 주키퍼를 제어하기 위한 주키퍼 클라이언트가 필요**하다.  
  > 액티브 네임노드에 장애가 발생할 경우 대기 상태에 있던 네임노드(스탠바이 네임노드)는 액티브 네임노드로 전환되고 문제가 발생한 네임노드는 HDFS에서 제외되어야한다. 이러한 기능을 수행하기 위해 ZKFC 제공.

  - **로컬 네임노드의 상태를 모니터링**
  - **주키퍼 세션 관리**
    - 정상일 경우, 주키퍼 마스터에 대한 세션을 유지 
  - **자동 장애 처리 기능**
    - 액티브 네임노드에 장애가 발생할 경우, ZKFC와 주키퍼 마스터간의 세션이 종료된다. 
    - 이때, 스탠바이 네임노드의 ZKFC가 이러한 상태 변화를 즉시 감지, 스탠바이 네임노드를 액티브 네임노드로 전환한다.
    - 그 후, HDFS 클러스터에서 기존 액티브 네임노드를 제거
  
- **네임노드**

  - 네임노드 내부에서 QJM(QuorumJournalManager)이 **저널 노드에 에디트로그를 출력**. 이때, **반드시 절반 이상의 저널노드에서 정상적으로 저장되었다는 응답을 받아야 에디트 로그를 파일 시스템 이미지를 반영**할 수 있다.
  - **스탠바이 네임노드는 일정 주기로 저널노드에서 에디트 로그를 조회해 스탠바이 네임노드가 보관하고 있는 파일 시스템 이미지를 갱신**한다.
  - 네임노드 HA를 구성할 경우, **보조네임노드를 실행할 필요가 없다.** **스탠바이 바이네임노드가 체크포인팅과 유사하게 동작**하기 때문.

---

### Reference

  - 책