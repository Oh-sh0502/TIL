# 캐시

<br>

### 캐싱(Caching)

이미 가져온 데이터나 계산된 결과값의 복사본을 저장함으로써 애플리케이션의 처리 속도를 높여준다.





### 웹 캐시(Web Cache)

사용자(client)가 웹 사이트(server)에 접속할 때, 정적 컨텐츠(이미지, JS, CSS 등)를 특정 위치(client, network 등)에 저장하여, 웹 사이트 서버에 해당 컨텐츠를 매번 요청하여 받는것이 아니라, 특정 위치에서 불러옴으로써 사이트 응답시간을 줄이고, 서버 트래픽 감소 효과를 볼 수 있는 정보기술이다.

![dfsf](https://user-images.githubusercontent.com/24764210/111657077-7368b280-884e-11eb-81ac-63e0c38adf0f.PNG)





### 웹 캐쉬의 종류

**1. Browser Caches**

브라우저의 로컬 저장소(= 하드디스크)에 이전에 방문한 웹페이지의 정적 자원(이미지, html, css, javascript)을 저장해 사용하는 것이다.

 

**2. Proxy Caches** = 웹 캐시

클라이언트와 서버 사이에 위치해서 중개 서버의 역할을 하는 캐시로 네트워크 상에서 동작한다. 다양한 회사, IPS(침입 차단 시스템)의 방화벽에 설치된다.



### 웹 캐시의 동작방법

**<동작 과정>**

1. 브라우저가 웹 캐시와 TCP 연결을 설정하고 웹 캐시에 있는 객체에 대한 HTTP 요청을 보낸다.

2. 웹 캐시는 객체의 사본이 캐시에 저장되어 있는지 확인한다. 저장되어 있다면 브라우저로 HTTP 응답 메세지와 함께 객체를 보낸다.

3. 저장되어 있지 않다면 origin 서버로 TCP 연결을 설정한다. 이 연결로 브라우저가 요청한 객체에 대한 HTTP 요청을 보낸다. origin 서버는 웹 캐시로 HTTP 응답 메시지와 함께 객체를 보낸다.

4. 웹 캐시가 origin 서버로부터 객체를 수신할 때, 객체를 저장 장치에 복사하고 객체의 사본을 HTTP 응답 메세지와 함께 브라우저로 보낸다.



### 웹 캐시의 장점

1. 클라이언트가 서버까지 가서 데이터를 요청하지 않고 캐시를 통해 빠르게 데이터를 가져올 수 있어 **응답시간을 줄일 수** 있다.
2. 한 기관에서 인터넷으로 접속하는 링크상의 **웹 트래픽**을 대폭 줄일 수 있다



### 웹 캐시의 단점

유저 브라우저에서 캐시가 바뀌지 않아 예전 코드와 충돌하는 경우가 생긴다. 

해결책 : 유저에게 캐시를 지워달라고 하면 된다.





### 웹 캐시 컨트롤 방법

브라우저는 한번 요청한 파일은 그 이후부터 캐시를 사용하지만, 만약 캐시된 내용을 수정해야 하거나 캐시되지 않아야 하는 내용이 있다면, 개발자가 설정할 수 있어야 한다. 브라우저는 HTTP Header를 사용하여 캐시를 컨트롤 한다. 

일반 적으로 캐싱은 GET 요청에서 처리한다.

일반적으로 200(가져오기 성공), 206 (부분 컨텐츠 응답), 301(다른 주소로 이동 후 가져옴), 404(가져올 게 없음) 상태 코드로 온 응답등을 캐싱할 수 있다.



  **Cache-Control** 헤더에 지시자를 전달하여 캐시를 제어하며 요청과 응답 양측 모두에 있다. 요청 메서드를 캐싱하는 일은 잘 없다.

![wltlwk](https://user-images.githubusercontent.com/24764210/111492504-130b3f80-8780-11eb-9f9c-7a9c5374e494.PNG)

- no-store : 아무것도 캐싱하지 않으려고 할 때 사용

- no-cache : 캐시를 쓰기 전에 서버에 캐시를 써도 되는지 물어보는 것

- must-revalidate : 만료된 캐시만 서버에 확인을 받도록 하는 것

- public : 공유 캐시(or 중개 서버)에 저장해도 된다는 뜻

- private : 브라우저같은 특정 사용자 환경에만 저장하라는 뜻

- max-age=(초 단위) : 캐시 유효시간 지정  

  ex) max-age=3600 → 1시간이 지나면 응답 캐시는 만료

  max-age=0 → 캐시서버는 항상 실제서버로 요청을 전달하여 유효성을 매번 확인해야 한다.

#### 기타 헤더들

- **Age** : 캐시 응답 때 나타나는데, max-age 시간 내에서 얼마나 흘렀는지 초 단위로 알려줍니다.

  max-age= 3600을 설정한 경우, 1분이 지나면, 

  Age: 60 으로 표시해줍니다.

- **Expires** : 응답 컨텐츠가 언제 만료되는지를 나타내며, Cache-Control의 max-age가 있는 경우 이 헤더는 무시됩니다.

  ex) Expires: Thu, 26 Jul 2018 07:28:00 GMT

- **ETag** : HTTP 컨텐츠가 바뀌었는지를 검사할 수 있는 태그입니다.

  ex ) Etag: W/"3bf2-wdj3VvN8/CvXVgafkI30/TyczHk"

- **If-None-Match** : 서버보고 ETag가 달라졌는 지 검사해서 ETag가 다를 경우에만 컨텐츠를 새로 내려주라는 뜻입니다. 만약 ETag가 같다면 서버는 **304 Not Modified**를 응답해서 캐시를 그대로 사용하게 합니다.

  ex) If-None-Match: W/"3bf2-wdj3VvN8/CvXVgafkI30/TyczHk"

![HTTPStaleness](https://user-images.githubusercontent.com/24764210/111666489-1ae9e300-8857-11eb-9ad8-917406a4bd37.png)





### Redis

> REmote DIctionary Server

고성능 key-value 저장소로서 리스트, 해시, 셋 정렬된 셋 등 여러 형식의 자료구조를 지원하는 NoSQ이다.

- 데이터를 디스크 또는 SSD에 저장하는 대부분의 데이터베이스 관리 시스템과는 달리 모든 Redis 인 메모리 데이터베이스로 데이터는 서버의 주 메모리에 상주합니다. 디스크에 액세스해야 할 필요를 없앰으로써 검색 시간으로 인한 지연을 방지하고 빠르게 데이터에 액세스할 수 있다.

  `인 메모리 데이터베이스` : 데이터 스토리지의 메인 메모리에 설치되어 운영되는 방식.

- Redis는 데이터를 disk에 저장할 수 있습니다. 따라서 Redis는 서버가 shutdown된 후에 restart 하더라도 disk에 저장해놓은 데이터를 다시 읽어서 데이터가 유실되지 않습니다. redis의 데이터를 disk에 저장하는 방식은 snapshot, AOF 방식이 있습니다.

  `Snapshot` : 스냅샷은 RDB에서도 사용하고 있는 어떤 특정 시점의 데이터를 DISK에 옮겨담는 방식을 뜻합니다. 

  `AOF` : Redis의 모든 write/update 연산 자체를 모두 log 파일에 기록하는 형태입니다. 서버가 재시작할 시 write/update를 순차적으로 재실행, 데이터를 복구합니다.

- 캐싱 : 다른 데이터베이스 "앞"에 배치된 Redis는 성능이 뛰어난 인 메모리 캐시를 생성하여 액세스 지연 시간을 줄이고, 처리량을 늘리며, 관계형 또는 NoSQL 데이터베이스의 부담을 줄여준다.

- 실시간 순위표 : Redis Sorted Set 데이터 구조를 사용하면 요소가 목록에 유지되고 점수에 따라 정렬됩니다. 이를 통해 손쉽게 동적 순위표를 생성하여 게임에서 앞서있는 사람이 누구인지 보여주거나, 좋아요를 가장 많이 받은 메시지를 게시하거나, 선두에 있는 사람이 누구인지 보여주려는 다양한 사례에 사용할 수 있습니다.







[자료 출처]

https://hahahoho5915.tistory.com/33

https://goddaehee.tistory.com/169













